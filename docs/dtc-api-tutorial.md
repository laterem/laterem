# Памятка программиста по работе с DTC

Этот документ описывает программную работу с DTC.

## Внешняя работа с DTC.
Чтобы работать с файлом DTC, для начала необходимо его скомпилировать, то есть преобразовать текст в формате DTC в структуру из объектов языка.
Для этого используется singleton класс `DTCCompiler` из модуля `dtc.dtc_compiler`.
```python
with open('test.dtc', mode='r') as file:
    txt = file.read()

dtcc = DTCCompiler()

dtc = dtcc.compile(txt)
``` 
В коде выше мы первым делом считали содержимое из DTC файла. Затем мы создали singleton экземпляр класса `DTCCompiler` и присвоили ему имя `dtcc`. Имея в распоряжении экземпляр класса `DTCCompiler`, мы можем использовать его метод `DTCCompiler.compile(txt)` для того, чтобы скомпилировать DTC.
Метод `DTCCompiler.compile(txt)` класса `DTCCompiler` принимает один аргумент - текст содержимого DTC файла.
Метод `DTCCompiler.compile(txt)` класса `DTCCompiler` возвращает объект класса `DTC`, которому мы присвоили имя `dtc`.

`DTC` объект представляет собой структуру данных, соответствующую результату описания задачи DTC файла. 

Объект класса `DTC` нам понадобится для получения значений ячеек, которые необходимо передать HTML разметке задачи, а так же для проверки правильности решения задачи, в зависимости от значений полей ввода интерфейса. 

Пока что, в объекте хранятся лишь инструкции, поэтому если мы попытаемся извлечь оттуда какую-либо полезную нам информацию, мы получим ссылки на объекты DTC-функций, с которыми мы не сможем работать снаружи среды класса.
Чтобы выполнить DTC и конкретизировать значения до констант, необходимо выполнить метод `DTC.execute()`
```python
dtc.execute()
ft = dtc.field_table
print(ft['id0'])
```
В коде выше мы сперва выполнили все инструкции к DTC-функциям нашего объекта DTC, а затем получили из него словарь в поле `DTC.field_table`.
Поле `DTC.field_table` представляет собой словарь, в котором ключам, которые являются именами изменяемых ячеек HTML разметки, соответствуют их строковые значения согласно данному DTC.
В результате работы кода выше на экран будет выведено значение, которое должно быть передано ячейке HTML разметки под именем "id0".

Чтобы провести проверку правильности решения задачи, имея значения полей ввода интерфейса, можно вызвать функцию `DTC.check(fields)`.
Функция `DTC.check(fields)` возвращает True, если задача решена верно, и False, если задача решена неверно. Она принимает один аргумент: словарь со значениями полей ввода интерфейса. В словаре ключам, являющимся именами полей ввода интерфейса, должны соответствовать их значения, введённые пользователем.

```python
fields = {'input1': "42",
          'input2': "Foobar"}
print(dtc.check(field))
```
В коде выше мы создаём словарь значений полей ввода интерфейса и выводим результат функции `DTC.check(fields)` на экран. В реальности словарь значений полей ввода интерфейса составляется из содержимого POST запроса на сервер.
> Обратите внимание:
> В словаре значений полей ввода интерфейса все значения полей ввода интерфейса хранятся в **строковом** виде, включая числовые.
Стоит отметить, что функция `DTC.check(fields)` корректно работает и в невыполненном состоянии объекта `DTC`, то есть до вызова метода `DTC.execute()`.

Полный пример кода с использованием DTC API для считывания данных и инструкций проверки из DTC из этого документа: 

```python
with open('test.dtc', mode='r') as file:
    txt = file.read()

dtcc = DTCCompiler()

dtc = dtcc.compile(txt)

dtc.execute()

ft = dtc.field_table
print(ft['id0'])

fields = {'input1': "42",
          'input2': "Foobar"}
print(dtc.check(field))
``` 

## Описание своих DTC-функций.
Набор встроенных DTC-функций, не являющихся служебными, описан в модуле `dtc.dtc_builtins`.
DTC-функции делятся на два вида: 
- Генераторы значений
- Функции проверки значений

Каждая DTC-функция генератора значений имеет вид:
```py
class FunctionName(DTCFunction):
    expected_argsc = N    
    def call(self, ns):
        ... # do something
        return something
```
Каждая DTC-функция хранится в виде отдельного класса. Вся основная работа функции описана в методе `DTCFunction.call(self, ns)` (**не путать с магическим методом `__call__()`!!!**) 
Метод **не принимает не вход аргументы DTC-функции**. Аргументы подаются объекту DTC-функции в конструкторе, функционал которого описан в родительском базовом классе DTCFunction. 
Чтобы внутри метода получить доступ к I-тому аргументу DTC-функции, необходимо вызвать функцию `self.getarg(ns, I)`. Важно передать ей аргумент `ns`, тот же, который получает метод `DTCFunction.call(self, ns)`.
Так же классу DTC-функции необходимо задать поле `DTCFunction.expected_argsc`, равное количеству ожидаемых аргументов этой функции.

Вид DTC-функции проверки значений аналогичен виду DTC-функции генератора значений, однако имеет существенные отличия.
```py
class FunctionName(DTCCheckerFunction):
    expected_argsc = N    
    def call(self, field, ns):
        ... # do something
        return something
```
Во-первых, DTС-функции проверки значений наследуются от класса `DTCCheckerFunction`.
Во-вторых, метод `DTCCheckerFunction.call(field, ns)` работает с дополнительным аргументом `field`, в котором хранится значение проверяемого поля.

Пример создания DTC-функций простейшего генератора случайных чисел и простейшей проверки на равенство значений в модуле `dtc.dtc_builtins`:

```py
from random import randint
from dtc_core import *

...

class RandInt(DTCFunction):
    expected_argsc = 2
    def call(self, ns):
        return randint(self.getarg(ns, 0), self.getarg(ns, 1))

class IsEqual(DTCCheckerFunction):
    expected_argsc = 1
    def call(self, field, ns):
        return field == self.getarg(ns, 0)

...

KEYWORD_TABLE = { 
    ...
    'Randint': RandInt,
    'Equal': IsEqual,
    ...
}
```

Все созданные DTC-функции необходимо занести в словарь `KEYWORD_TABLE`, расположенный в самом низу модуля. Это нужно для того, чтобы компилятор мог установить соответсвие между строковым названием функции и её классовым представлением. 
В данном словаре необходимо завести новую пару ключ-значение, в которой ключом будет строковое название функции, которое будет использоваться в DTC файле, а значением - имя класса без кавычек и скобок. 