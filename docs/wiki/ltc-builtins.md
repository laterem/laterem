# Руководство по работе со встроенными функциями LTC

## Математические операции

### Sum(a, b)

Сложение `а + b`

### Substract(a, b)

Вычитание `a - b`

### Multiply(a, b)

Умножение `a * b`

### Divide(a, b)

Деление `a / b`

### Mod(a, b)

Остаток от деления `a` на `b` (`a % b`)

### Power(a, b)

Возведение `a` в степень `b` (`a^b`)

### Round(a, b)

Округление числа `a` до `b` знаков после запятой

### ConvertBase(n, base_from, base_to, precision)

Перевод строчного представления числа `n` с системы счисления с основанием `base_from` в систему счисления с основанием `base_to`, оставляя количество знаков после запятой, равное `precision`

### Veclen(a, b)

Длина вектора `{a; b}`.
Считается по Теореме Пифагора `sqrt(a^2+b^2)`

### Calc(string)

Вычисление математического выражения в `string`.
> Функция работает исключительно с литералами и не принимает на вход выражение с переменными, в том числе полями LTC.

## Генерация случайных значений

### Rand10(a, b)

Случайное десятиричное целое число в промежутке между `a` и `b`, включая обе граничные точки.

### Rand2(a, b)

Случайное двоичное целое число между `a` и `b`, включая обе граничные точки.

> `a` и `b` указываются как десятиричные числа. Может быть изменено в дальнейших версиях языка.

### RandFloat10(a, b, precision)

Случайное десятиричное дробное число в промежутке между `a` и `b`, включая обе граничные точки с количеством знаков после запятой, равным `precision`

### RandFloat2(a, b, precision)

Случайное двоичное дробное число в промежутке между `a` и `b`, включая обе граничные точки с количеством знаков после запятой, равным `precision`

> `a` и `b` указываются как десятиричные числа. Может быть изменено в дальнейших версиях языка.

## Работа со списками

### Reverse(a)

Список `a`, перевёрнутый задом наперёд.

## Основные чекеры

### value?Equal(a)

Проверка пройдена, если `value` строго равен `a`
> Синтаксический сахар: вызов функции `Equal` может быть опущен, если `a` является вызовом другой функции. Например, запись `answer?Sum(idx1, idx2)` будет эквивалентна записи `answer?Equal(Sum(idx1, idx2))`

### value?EqualText(a)

Проверка пройдена, если `value` текстово равен `a`.
В отличии от `value?Equal(a)`, функция `value?EqualText(a)` игнорирует регистр букв, обрезает пробелы по краям строки и считает `ё` и `е` одной буквой.

### value?IsNotEqual(a)

Проверка пройдена, если `value` отличен от `a`

### value?MetricEqual(a, metric)

Проверка пройдена, если `value` заканчивается на `metric`, а строка до этого численно равна `a`

---

## Квадратные уравнения

> Блок функций будет выделен в отдельный пакет и значительно переработан в будущих версиях языка.

### QuadEquation(a, b, c)

Генерация корректного строчного представления квадратного уравнения с коэффициентами `a` (при x²), `b` (при x) и `c` (свободный член).

### value?Roots(a, b, c, accuracy)

Проверка на соответствие `value` одному из корней квадратного уравнения с коэффициентами `a` (при x²), `b` (при x) и `c` (свободный член).
Корни округляются до количества знаков после запятой, равному `accuracy`.
В случае, если у данного квадратного уравнения не существует корней в действительных числах, проверка пройдена, если `value` будет равно строке "нет корней" (без учёта регистра)

---

## Работа с булевыми выражениями

### EvalBoolean(string, values)

Вычисление логического выражения в `string`.
`values` - список значений. Если в `string` используются переменные, им будут присвоены значения из `values`, соответствующие положению переменной в отсортированном по алфавиту перечне всех используемых в выражении переменных
> Роль аргумента `values` изменится с добавлением структуры словаря в язык LTC

### value?IsBooleanIdentical(string)

Проверка пройдена, если булевая функция в `value` тождественна булевой функции в `string` при любых значениях переменных.

### value?IsBooleanFormulaOperators(operators)

Проверка пройдена, если булевая функция в `value` не использует никакие другие операторы, кроме тех, которые перечислены в списке `operators`.
> Операторы в `operators` передаются их буквенными обозначениями: </br>
> & -- "AND" </br>
> | -- "OR" </br>
> ! -- "NOT" </br>
